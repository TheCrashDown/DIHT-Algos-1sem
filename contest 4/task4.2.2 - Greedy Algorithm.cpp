/*  Task :
    В большой IT-фирме есть только одна переговорная комната. 
    Желающие посовещаться заполняют заявки с желаемым временем начала и конца. 
    Ваша задача определить максимальное количество заявок, которое может быть удовлетворено. 
    Число заявок ≤ 100000.

    Решение использует идеи жадного алгоритма.

    Доказательство корректности использования жадности :

    Предположим противное. Пусть жадный алгоритм построил некую последовательность
    заявок [ L(i)..R(i) ], которая не является оптимальной. Рассмотрим оптимальную последоватеьлность
    [ oL(i)..oR(i) ]. Назовем переломным (Ip) тот номер i, на котором выбранный жадно отрезок отличается
    от оптимально выбранного, допуская при этом, что i может быть равен нулю, т.е. расхождение начинается
    с первого же выбранного отрезка. Заметим, что R(Ip) <= oR(Ip), т.к. жадный алгоритм выбирает отрезок с 
    наименьшим возможным правым концом, а также L(Ip) > R(Ip - 1) и oL(Ip) > oR(Ip - 1), т.к. с таким условием
    строятся последовательности, а до номера переломного номера Ip последовательности совпадали. Но тогда можно в 
    оптимальной последовательности заменить отрезок ( oL(i), oR(i) ) на отрезок ( L(i), R(i) ), не нарушив при 
    этом корректность и оптимальность последовательности (убрали один, добавили один - количество не поменялось). 
    После такой замены продолжаем подобные рассуждения до тех пор, пока не закончатся переломные моменты. Когда они 
    закончатся, оптимальная последовательность будет совпадать с построенной жадно, а значит жадный метод 
    действительно выдает оптимальное решение.

    developed by Crashdown
    
*/

#include <iostream>
#include <vector>
#include <algorithm>

struct Request {
    int start = 0;
    int end = 0;

    Request(){}
    Request(int _start, int _end) : start(_start), end(_end) {}

    bool operator< (Request& b){
        return end < b.end;
    }
};

int main()
{
    std::vector<Request> request;

    int start = 0;
    int end = 0;
    std::cin >> start >> end;
    request.push_back(Request(start, end));

    while(!std::cin.eof()){
        std::cin >> start >> end;
        request.push_back(Request(start, end));
    }

    std::sort(request.begin(), request.end());

    int count = 1;
    int prev = 0;
    for(int i = 1; i < request.size(); ++i){
        if(request[i].start >= request[prev].end){
            ++count;
            prev = i;
        }
    }

    std::cout << count;

    return 0;
}
